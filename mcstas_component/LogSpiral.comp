/*******************************************************************************
*
* McStas, Vector2D ray-tracing package
*         Copyright (C) 1997-2011, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Logarithmic spiral
*
* %I
* Written by: Christoph Herb
* Date: 2 Sep 2021
* Origin: TUM
*
* Simulation of a mirror surface shaped like a log spiral. Newton Raphson is used for the implementaion
*
*
* %D
*
* The origin of the component coincides with the origin of the log spiral coordinate system. The spiral starts at zstart and is defined by the angle psi, which indicates
* under which angle rays from the origin hit the mirror.
*
* %P
* INPUT PARAMETERS:

* OUTPUT PARAMETERS

* %D
*
*
*
* %E
*******************************************************************************/

DEFINE COMPONENT LogSpiral
DEFINITION PARAMETERS()
SETTING PARAMETERS (
    zstart=1,
    zend=3,
    psi=5,
    precision=1e-5,
	max_iterations=10,
    placeholder=0
)

OUTPUT PARAMETERS (
)

SHARE
%{
%include "ref-lib"
double dt; // time to propagate the neutron onto the mirror surface
double interaction; //if no interaction can take place neutrons are propagated onto the next component
	///////////////////////////////////////////////////////////////////////////
/////////////// Some Structures
///////////////////////////////////////////////////////////////////////////
typedef struct LogSpir{
    double zstart;
    double zend;
    double psi;
    double psi_rad;//=psi*DEG2RAD;
    double k;//=arctan(psi_rad);
    double precision;
    double theta_end;
    double x_end;
	int branches;
} LogSpir;//logspiral will be our surface to reflect from; nice

typedef struct Vector2D{
	double z;
	double x;
	double vz;
	double vx;
} Vector2D;//Structure for a 2D Vector2D

typedef struct BranchTime{
	double phi_rot;//rotation angle of the branch
	double t;//time of interaction
	double theta_int;//angle under which the interaction takes place
} BranchTime;//Structure for a 2D Vector2D


void rotateNeutron(Vector2D *neutron, Vector2D initneut, double theta_rot){
	double sint = sin(theta_rot);
	double cost = cos(theta_rot);
	neutron->z = cost*initneut.z - sint*initneut.x;
    neutron->x = sint*initneut.z + cost*initneut.x;
    neutron->vz= cost*initneut.vz - sint*initneut.vx;
    neutron->vz= sint*initneut.vz + cost*initneut.vx;
}	
	
	
	
Neutron2Dinit(Vector2D *neutron, double z, double x, double vz, double vx){
	neutron->z = z;
	neutron->x = x;
	neutron->vz = vz;
	neutron->vx = vx;
}

void reflected_direction(Vector2D normal, Vector2D *neutron){
	double vz = neutron->vz;
	double vx = neutron->vx;
	double vdotn = vz*normal.vz + vx*normal.vx;
	vx = vx-2*vdotn*normal.vx;
	vz = vz-2*vdotn*normal.vz;
	neutron->vz = vz;
	neutron->vx = vx;
}



///////////////////////////////////////////////////////////////////////////
/////////////// Collision handling functions
///////////////////////////////////////////////////////////////////////////
double newton_theta_end(LogSpir logspir, double theta){
	return cos(theta)*logspir.zstart*exp(logspir.k*theta)-logspir.zend;
}
double newton_theta_end_derivative(LogSpir logspir, double theta){
	return logspir.zstart*exp(logspir.k*theta)*(cos(theta)*logspir.k-sin(theta));
}

double return_r(double theta, double k, double zstart){
    return zstart*exp(k*theta);
};

Vector2D return_cart_coordsspiral(LogSpir logspir, double theta){
	struct Vector2D n;
	double r = return_r(theta, logspir.k, logspir.zstart);
	n.z = cos(theta)*r;
	n.x = sin(theta)*r;
	return n;
}

double return_approx_theta_end(LogSpir logspir){
	printf("logspir k %f\n", logspir.k);
    return log(logspir.zend/logspir.zstart)/logspir.k;
};

double return_precise_theta_end(LogSpir logspir, int max_iterations){
	double theta_0 = return_approx_theta_end(logspir);
	double theta_n;
	for (int ii; ii < max_iterations; ii++){
		printf("theta0=%f",theta_0);
		theta_n = theta_0 -  newton_theta_end(logspir, theta_0)/newton_theta_end_derivative(logspir, theta_0);
		if (fabs(theta_0-theta_n)<logspir.precision){
			return theta_n;
			}
		theta_0 = theta_n;
	}
	return -10.0;
}

void LogSpirinit(LogSpir *logspir, double zstart, double zend, double psi, double precision, double max_iterations){
	logspir->zstart = zstart;
	logspir->zend = zend;
	logspir->psi = psi;
	logspir->psi_rad = psi*DEG2RAD;
	logspir->k = 1/tan(logspir->psi_rad);
	logspir->precision = precision;
	logspir->theta_end = return_precise_theta_end(*logspir, max_iterations);
}


double return_approx_theta_int(LogSpir logspir){//approximating by intersection with line seems comp expensive + if the intersection is far away
	return logspir.theta_end/2;
}

double return_precise_theta_int(LogSpir logspir, Vector2D n, double max_iterations){//
	double theta_0, theta_n;
	double m = n.vx/n.vz;
	double x0 = n.x-n.z/n.vz*n.vx;
	double f(double theta){
		return logspir.zstart*exp(logspir.k*theta)*(sin(theta)-m*cos(theta))-x0;
	}
	double f_derivative(double theta){
		return logspir.zstart*exp(logspir.k*theta)*(cos(theta)*(1-logspir.k*m)+ sin(theta)*(logspir.k+m));
	}
	theta_0 = return_approx_theta_int(logspir);
	for (int ii; ii<max_iterations; ii++ ){
		theta_n = theta_0-f(theta_0)/f_derivative(theta_0);
		if (fabs(theta_n-theta_0)<logspir.precision){
			if ((0<theta_n)&&(theta_n<logspir.theta_end)){
				return theta_n;
			}
			return -10;
		}
		theta_0 = theta_n;


	}
	return -10;
}

float return_intersection_time(LogSpir logspir, double z0, double x0, double vz, double vx, double theta_int){
	Vector2D int_coord;
	double t;
	if (theta_int > 0){
		int_coord = return_cart_coordsspiral(logspir, theta_int);
		t = (int_coord.z-z0)/vz;
		if (t > 0.0001){
			return t;
		}
	}
	return -1.0;
}




BranchTime return_first_interaction(LogSpir logspir, float z0, float x0, float vz, float vx){
	double t;	
	double min_time = -1;
	double theta_rot;
	double theta_rot_min = -1;
	double theta_int;
	double theta_int_min = -1;

	BranchTime brt;
	Vector2D init_neut;
	Neutron2Dinit(&init_neut, z0, x0, vz, vx);
	Vector2D rotneut;
	Vector2D *protneut;
	protneut = &rotneut;
	for (int kk=0; kk++; kk<logspir.branches){
		theta_rot = -kk*logspir.theta_end;
		//rotate the rotneut
		rotateNeutron(protneut, init_neut, theta_rot);
		theta_int = return_precise_theta_int(logspir, rotneut, 10);
		t = return_intersection_time(logspir, rotneut.z, rotneut.x, rotneut.vz, rotneut.vx, theta_int);
		if (t>0){
			if (t<min_time || min_time<0){
				min_time = t;
				theta_rot_min = theta_rot;
				theta_int_min = theta_int;
			}
		}
		
	}
	brt.phi_rot = (theta_rot_min);
	brt.theta_int = (theta_int_min);
	brt.t = min_time;
	return brt;

}

Vector2D return_normal_vec(LogSpir logspir, double theta){//returns the normalized normal vector to the surface
	Vector2D n2d;
	double k = logspir.k;
	double prefac = 1/sqrt(1+k*k);
	n2d.vz = (cos(theta)+k*sin(theta))*prefac;
	n2d.vx = (sin(theta)-k*cos(theta))*prefac;
	return n2d;
}

int evaluate_first_interaction(LogSpir logspir, Vector2D *neutron){
	BranchTime brt;
	brt = return_first_interaction(logspir, neutron->z, neutron->x, neutron->vz, neutron->vx);
	double t_prop;
	double theta_int;
	double phi_rot;
	Vector2D n;
	Vector2D n_rot;
	t_prop = brt.t;
	theta_int = brt.theta_int;
	phi_rot = brt.phi_rot;
	if (t_prop < 0){
		return 0;
	}
	else{
		neutron->z = t_prop*neutron->vz;
		neutron->x = t_prop*neutron->vx;//propagate neutron
		n = return_normal_vec(logspir, theta_int);
		rotateNeutron(&n_rot, n, phi_rot);
		reflected_direction(n_rot, neutron);
		return 1;
	}
}



double return_time_first_interaction(LogSpir logspir, double theta_int, Vector2D *n){
	double z_int = cos(theta_int)*return_r(theta_int, logspir.k, logspir.zstart);
	return z_int/n->vz;
}


///////////////////////////////////////////////////////////////////////////
/////////////// End of functions
///////////////////////////////////////////////////////////////////////////
//Vector2D n;
double dt;
double theta_int;
LogSpir logspir;
LogSpir *logspirp;
Vector2D n;
Vector2D *ptrn;
Vector2D normal;

%}


DECLARE
%{

%}

INITIALIZE
%{
	ptrn = &n;
	logspirp = &logspir;
    double psi_rad;//=psi*DEG2RAD;
    double k;//=arctan(psi_rad);
    double theta_end;
    double x_end;
	///////////////////////////////////////////////////////////////////////////
	/////////////// Initialize the logarithmic spiral
	///////////////////////////////////////////////////////////////////////////
	LogSpirinit(logspirp, zstart, zend, psi, precision, max_iterations);

	printf("theta_end%f", logspir.theta_end);
%}

	// Test user input for illegal values

TRACE
%{
  PROP_Z0;
  
  Neutron2Dinit(ptrn, z, x, vz, vx);//puts all of the neutron info into the pointer ptrn pointing to n
  for (int ii = 0; ii++; ii < 100){
	  //propagate neutron to the next interaction 
	  //interaction = evaluate_first_interaction(logspir, ptrn);
  }
  
  };

%}


FINALLY
%{
%}

MCDISPLAY
%{


%}

END
