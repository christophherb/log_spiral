/*******************************************************************************
*
* McStas, Vector2D ray-tracing package
*         Copyright (C) 1997-2011, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Logarithmic spiral
*
* %I
* Written by: Christoph Herb
* Date: 2 Sep 2021
* Origin: TUM
*
* Simulation of a mirror surface shaped like a log spiral. Newton Raphson is used for the implementaion
*
*
* %D
*
* The origin of the component coincides with the origin of the log spiral coordinate system. The spiral starts at zstart and is defined by the angle psi, which indicates
* under which angle rays from the origin hit the mirror.
*
* %P
* INPUT PARAMETERS:

* OUTPUT PARAMETERS

* %D
*
*
*
* %E
*******************************************************************************/

DEFINE COMPONENT LogSpiral
DEFINITION PARAMETERS()
SETTING PARAMETERS (
    zstart=1,
    zend=3,
    psi=5,
    precision=1e-5,
	max_iterations=10,
    placeholder=0
)

OUTPUT PARAMETERS (
)

SHARE
%{
%include "ref-lib"
double dt; // time to propagate the neutron onto the mirror surface
	///////////////////////////////////////////////////////////////////////////
/////////////// Some Structures
///////////////////////////////////////////////////////////////////////////
typedef struct LogSpir{
    double zstart;
    double zend;
    double psi;
    double psi_rad;//=psi*DEG2RAD;
    double k;//=arctan(psi_rad);
    double precision;
    double theta_end;
    double x_end;
} LogSpir;//logspiral will be our surface to reflect from; nice

typedef struct Vector2D{
	double z;
	double x;
	double vz;
	double vx;
} Vector2D;//Structure for a 2D Vector2D

///////////////////////////////////////////////////////////////////////////
/////////////// Collision handling functions
///////////////////////////////////////////////////////////////////////////
double newton_theta_end(LogSpir logspir, double theta){
	return cos(theta)*logspir.zstart*exp(logspir.k*theta)-logspir.zend;
}
double newton_theta_end_derivative(LogSpir logspir, double theta){
	return logspir.zstart*exp(logspir.k*theta)*(cos(theta)*logspir.k-sin(theta));
}

double return_r(double theta, double k, double zstart){
    return zstart*exp(k*theta);
};

Vector2D return_cart_coordsspiral(LogSpir logspir, double theta){
	struct Vector2D n;
	double r = return_r(theta, logspir.k, logspir.zstart);
	n.z = cos(theta)*r;
	n.x = sin(theta)*r;
	return n;
}

double return_approx_theta_end(LogSpir logspir){
	printf("logspir k %f\n", logspir.k);
    return log(logspir.zend/logspir.zstart)/logspir.k;
};

double return_precise_theta_end(LogSpir logspir, int max_iterations){
	double theta_0 = return_approx_theta_end(logspir);
	double theta_n;
	for (int ii; ii < max_iterations; ii++){
		printf("theta0=%f",theta_0);
		theta_n = theta_0 -  newton_theta_end(logspir, theta_0)/newton_theta_end_derivative(logspir, theta_0);
		if (fabs(theta_0-theta_n)<logspir.precision){
			return theta_n;
			}
		theta_0 = theta_n;
	}
	return -10.0;
}

double return_approx_theta_int(LogSpir logspir){//approximating by intersection with line seems comp expensive + if the intersection is far away
	return logspir.theta_end/2;
}

double return_precise_theta_int(LogSpir logspir, Vector2D n, double max_iterations){//
	double theta_0, theta_n;
	double m = n.vx/n.vz;
	double x0 = n.x-n.z/n.vz*n.vx;
	double f(double theta){
		return logspir.zstart*exp(logspir.k*theta)*(sin(theta)-m*cos(theta))-x0;
	}
	double f_derivative(double theta){
		return logspir.zstart*exp(logspir.k*theta)*(cos(theta)*(1-logspir.k*m)+ sin(theta)*(logspir.k+m));
	}
	theta_0 = return_approx_theta_int(logspir);
	for (int ii; ii<max_iterations; ii++ ){
		theta_n = theta_0-f(theta_0)/f_derivative(theta_0);
		if (fabs(theta_n-theta_0)<logspir.precision){
			if ((0<theta_n)&&(theta_n<logspir.theta_end)){
				return theta_n;
			}
			return -10;
		}
		theta_0 = theta_n;


	}
	return -10;
}

Vector2D return_normal_vec(LogSpir logspir, double theta){//returns the normalized normal vector to the surface
	Vector2D n2d;
	double k = logspir.k;
	double prefac = 1/sqrt(1+k*k);
	n2d.vz = (cos(theta)+k*sin(theta))*prefac;
	n2d.vx = (sin(theta)-k*cos(theta))*prefac;
	return n2d;
}

void reflected_direction(Vector2D normal, double *z, double *x, double *vz, double *vx){
	double vdotn = (*vz)*normal.vz + (*vx)*normal.vx;
	(*vx) = (*vx)-2*vdotn*normal.vx;
	(*vz) = (*vz)-2*vdotn*normal.vz;
}

double return_time_first_interaction(LogSpir logspir, double theta_int, Vector2D *n){
	double z_int = cos(theta_int)*return_r(theta_int, logspir.k, logspir.zstart);
	return z_int/n->vz;
}

void Neutron2Dinit(Vector2D *neutron, double z, double x, double vz, double vx){
	neutron->z = z;
	neutron->x = x;
	neutron->vz = vz;
	neutron->vx = vx;
}

void LogSpirinit(LogSpir *logspir, double zstart, double zend, double psi, double precision, double max_iterations){
	logspir->zstart = zstart;
	logspir->zend = zend;
	logspir->psi = psi;
	logspir->psi_rad = psi*DEG2RAD;
	logspir->k = 1/tan(logspir->psi_rad);
	logspir->precision = precision;
	logspir->theta_end = return_precise_theta_end(*logspir, max_iterations);
}
///////////////////////////////////////////////////////////////////////////
/////////////// End of functions
///////////////////////////////////////////////////////////////////////////
//Vector2D n;
double dt;
double theta_int;
LogSpir logspir;
LogSpir *logspirp;
Vector2D n;
Vector2D *ptrn;
Vector2D normal;

%}


DECLARE
%{

%}

INITIALIZE
%{
	ptrn = &n;
	logspirp = &logspir;
    double psi_rad;//=psi*DEG2RAD;
    double k;//=arctan(psi_rad);
    double theta_end;
    double x_end;
	///////////////////////////////////////////////////////////////////////////
	/////////////// Initialize the logarithmic spiral
	///////////////////////////////////////////////////////////////////////////
	LogSpirinit(logspirp, zstart, zend, psi, precision, max_iterations);

	printf("theta_end%f", logspir.theta_end);
%}

	// Test user input for illegal values

TRACE
%{

  PROP_Z0;
  Neutron2Dinit(ptrn, z, x, vz, vx);
  theta_int = return_precise_theta_int(logspir, *ptrn, max_iterations);
  //printf("theta int %f\n", theta_int);
  if (theta_int<0){
	;
  }else{
  	normal = return_normal_vec(logspir, theta_int);
  	dt = return_time_first_interaction(logspir, theta_int, ptrn);
  	PROP_DT(dt);
  	reflected_direction(normal, &z, &x, &vz, &vx);
  	SCATTER;
  };

%}


FINALLY
%{
%}

MCDISPLAY
%{


%}

END
