/*******************************************************************************
*
* McStas, part_log ray-tracing package
*         Copyright (C) 1997-2011, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Logarithmic spiral
*
* %I
* Written by: Christoph Herb
* Date: 2 Sep 2021
* Origin: TUM
*
* Simulation of a mirror surface shaped like a log spiral. Newton Raphson is used for the implementaion
*
*
* %D
*
* The origin of the component coincides with the origin of the log spiral coordinate system. The spiral starts at zstart and is defined by the angle psi, which indicates
* under which angle rays from the origin hit the mirror.
*
* %P
* INPUT PARAMETERS:

* OUTPUT PARAMETERS

* %D
*
*
*
* %E
*******************************************************************************/

DEFINE COMPONENT LogSpiral
DEFINITION PARAMETERS()
SETTING PARAMETERS (
    zstart=1,
    zend=3,
    psi=5,
	phi_rot=0,
    precision=1e-8,
	max_iterations=10,
	mValue = 4,
	branches = 2,
    placeholder=0
)

OUTPUT PARAMETERS (
)

SHARE
%{
%include "ref-lib"
double dt; // time to propagate the neutron onto the mirror surface
double interaction; //if no interaction can take place neutrons are propagated onto the next component
	///////////////////////////////////////////////////////////////////////////
/////////////// Some Structures
///////////////////////////////////////////////////////////////////////////
typedef struct LogSpir{
    double zstart;
    double zend;
    double psi;
    double psi_rad;//=psi*DEG2RAD;
    double k;//=arctan(psi_rad);
    double precision;
    double theta_end;
	double phi_rot;//the angle between the individual arms of the spiral defaults to theta_end
	double mValue;
    double x_end;
	double mindistance;
	int branches;
} LogSpir;//logspiral will be our surface to reflect from; nice

typedef struct part_log{
	double z;
	double y;
	double x;
	double vz;
	double vy;
	double vx;
} part_log;//Structure for a 2D part_log

double getRandomLog() {
    return (double)lrand48()/RAND_MAX;
}

typedef struct BranchTime{
	double phi_rot;//rotation angle of the branch
	double t;//time of interaction
	double theta_int;//angle under which the interaction takes place
} BranchTime;//Structure for a 2D part_log

double returnz(part_log n){
	return n.z;
}

double returnvz(part_log n){
	return n.vz;
}

double returny(part_log n){
	return n.y;
}

double returnvy(part_log n){
	return n.vy;
}

double returnx(part_log n){
	return n.x;
}

double returnvx(part_log n){
	return n.vx;
}
#define V2Q_conic 1.58825361e-3
#define Q2V_conic 629.622368

double calcSupermirrorReflectivityLog(double q, double m, double R_0, double Q_c){
    double arg;
    double beta = 0;
    double alpha = 2.5;
    double W = 0.004;
    double weight = 1.0; //neutron weight to be transformed
    q = fabs(q);
    if (m >= 10){
        return weight;
    }
    if (W==0 && alpha==0) {
      m=m*0.9853+0.1978;
      W=-0.0002*m+0.0022;
      alpha=0.2304*m+5.0944;
      beta=-7.6251*m+68.1137;
      if (m<=3) {
	    alpha=m;
	    beta=0;
        }
    }
    arg = W > 0 ? (q - m*Q_c)/W : 11;
    if (arg > 10 || m <= 0 || Q_c <=0 || R_0 <= 0) {
      weight = 0.0;
      return weight;
    }

    if (m < 1) { Q_c *= m; m=1; }

    if(q <= Q_c) {
      weight = R_0;
      return weight;
    }


    weight = R_0*0.5*(1 - tanh(arg))*(1 - alpha*(q - Q_c) + beta*(q - Q_c)*(q - Q_c));
    return weight;
}

void rotate_vector(part_log *neutron, part_log initneut, double theta_rot){
	double sint = sin(theta_rot);
	double cost = cos(theta_rot);
	neutron->z = cost*initneut.z - sint*initneut.x;
    neutron->x = sint*initneut.z + cost*initneut.x;
    neutron->vz= cost*initneut.vz - sint*initneut.vx;
    neutron->vx= sint*initneut.vz + cost*initneut.vx;
}



part_log Neutron2Dinit(part_log *neutron, double z, double y, double x, double vz, double vy, double vx){
	neutron->z = z;
	neutron->x = x;
	neutron->vz = vz;
	neutron->vx = vx;
	neutron->y = y;
	neutron->vy = vy;
	return *neutron;
}

void reflect_neutron(part_log normal, part_log *neutron, double mValue){
	//first check if the reflection takes place 

	double vz = neutron->vz;
	double vx = neutron->vx;
	double vdotn = vz*normal.vz + vx*normal.vx;
	double weight = calcSupermirrorReflectivityLog(V2Q_conic*2*vdotn, mValue, 0.995, 0.0218);
	//printf("weight %f\n", weight);
	if (getRandomLog() <= weight){
		vx = vx-2*vdotn*normal.vx;
		vz = vz-2*vdotn*normal.vz;
		neutron->vz = vz;
		neutron->vx = vx;
	}
	else{
		;
	}
	
}



///////////////////////////////////////////////////////////////////////////
/////////////// Collision handling functions
///////////////////////////////////////////////////////////////////////////
double newton_theta_end(LogSpir logspir, double theta){
	return cos(theta)*logspir.zstart*exp(logspir.k*theta)-logspir.zend;
}
double newton_theta_end_derivative(LogSpir logspir, double theta){
	return logspir.zstart*exp(logspir.k*theta)*(cos(theta)*logspir.k-sin(theta));
}

double return_r(double theta, double k, double zstart){
    return zstart*exp(k*theta);
};

part_log return_cart_coordsspiral(LogSpir logspir, double theta){
	struct part_log n;
	double r = return_r(theta, logspir.k, logspir.zstart);
	n.z = cos(theta)*r;
	n.x = sin(theta)*r;
	return n;
}

double return_approx_theta_end(LogSpir logspir){
	//printf("logspir k %f\n", logspir.k);
    return log(logspir.zend/logspir.zstart)/logspir.k;
};

double return_precise_theta_end(LogSpir logspir, int max_iterations){
	double theta_0 = return_approx_theta_end(logspir);
	double theta_n;
	for (int ii; ii < max_iterations; ii++){
		//printf("theta0=%f",theta_0);
		theta_n = theta_0 -  newton_theta_end(logspir, theta_0)/newton_theta_end_derivative(logspir, theta_0);
		if (fabs(theta_0-theta_n)<logspir.precision){
			return theta_n;
			}
		theta_0 = theta_n;
	}
	return -10.0;
}

void LogSpirinit(LogSpir *logspir, double zstart, double zend, double psi, double phi_rot, double mValue, double precision, double max_iterations, int branches){
	logspir->zstart = zstart;
	logspir->zend = zend;
	logspir->psi = psi;
	logspir->psi_rad = psi*DEG2RAD;
	logspir->mValue = mValue;
	logspir->k = 1/tan(logspir->psi_rad);
	logspir->precision = precision;
	logspir->branches = branches;
	logspir->theta_end = return_precise_theta_end(*logspir, max_iterations);
	logspir->phi_rot = phi_rot > 0 ? phi_rot : logspir->theta_end; //the rotation of the spirals is by default theta _end
	logspir->mindistance = 2*sin(logspir->theta_end/2)*zstart;
}


double return_approx_theta_int(LogSpir logspir){//approximating by intersection with line seems comp expensive + if the intersection is far away
	return logspir.theta_end/2;
}

double return_precise_theta_int(LogSpir logspir, part_log n, double max_iterations){//
	double theta_0, theta_n;
	double m = n.vx/n.vz;
	double x0 = n.x-n.z/n.vz*n.vx;
	double f(double theta){
		return logspir.zstart*exp(logspir.k*theta)*(sin(theta)-m*cos(theta))-x0;
	}
	double f_derivative(double theta){
		return logspir.zstart*exp(logspir.k*theta)*(cos(theta)*(1-logspir.k*m)+ sin(theta)*(logspir.k+m));
	}
	theta_0 = return_approx_theta_int(logspir);
	for (int ii; ii<max_iterations; ii++ ){
		theta_n = theta_0-f(theta_0)/f_derivative(theta_0);
		if (fabs(theta_n-theta_0)<logspir.precision){
			if ((0<theta_n)&&(theta_n<logspir.theta_end)){
				return theta_n;
			}
			return -10;
		}
		theta_0 = theta_n;


	}
	return -10;
}

float return_intersection_time(LogSpir logspir, double z0, double x0, double vz, double vx, double theta_int){
	part_log int_coord;
	double t;
	if (theta_int > 0){
		int_coord = return_cart_coordsspiral(logspir, theta_int);//cart coords of the interaction
		////printf("z of spiral %f z0 = %f\n", int_coord.z, z0);
		t = (int_coord.z-z0)/vz;
		if (t*t > 0.25*logspir.mindistance*logspir.mindistance/(vz*vz+vx*vx)){//minimum distance between two mirrors (sensible distance, smaller makes no sense)
			//printf("z of spiral %f z0 = %f vz = %f, t = %f \n ", int_coord.z, z0, vz, t);
			return t;
		}
	}
	return -1.0;
}




BranchTime return_first_interaction(LogSpir logspir, float z0, float x0, float vz, float vx){
	double t;
	double min_time = -1;
	double theta_rot;
	double theta_rot_min = -1;
	double theta_int;
	double theta_int_min = -1;

	BranchTime brt;
	part_log init_neut;
	init_neut = Neutron2Dinit(&init_neut, z0, 0, x0, vz, 0, vx);//don't need y for this so we just put it to zero
	part_log rotneut;
	for (int kk=0; kk<logspir.branches; kk++){//instead of rotating the device we rotate neutron to calculate the intersection time--> lowest wins
		theta_rot = -kk*logspir.phi_rot;
		//rotate the rotneut
		rotate_vector(&rotneut, init_neut, theta_rot);
		theta_int = return_precise_theta_int(logspir, rotneut, 10);
		//printf("thetaint %f vz berfore %f\n", theta_int, init_neut.vz);
		t = return_intersection_time(logspir, rotneut.z, rotneut.x, rotneut.vz, rotneut.vx, theta_int);
		if (t>0){
			if (t<min_time || min_time<0){
				min_time = t;
				theta_rot_min = theta_rot;
				theta_int_min = theta_int;
			}
		}

	}
	//
//printf("phi rot %f, theta_int %f, time %f", theta_rot_min, theta_int_min, min_time);
	brt.phi_rot = (theta_rot_min);
	brt.theta_int = (theta_int_min);
	brt.t = min_time;
	return brt;

}

part_log return_normal_vec(LogSpir logspir, double theta){//returns the normalized normal vector to the surface
	part_log n2d;
	double k = logspir.k;
	double prefac = 1/sqrt(1+k*k);
	n2d.vz = (cos(theta)+k*sin(theta))*prefac;
	n2d.vx = (sin(theta)-k*cos(theta))*prefac;
	return n2d;
}



void propagate_neutron(part_log *incoming, double dt){
	incoming->x += incoming->vx*dt;
	incoming->z += incoming->vz*dt;
	incoming->y += incoming->vy*dt;
}

int evaluate_first_interaction(LogSpir logspir, part_log *neutron){
	BranchTime brt;
	brt = return_first_interaction(logspir, neutron->z, neutron->x, neutron->vz, neutron->vx);
	double t_prop;
	double theta_int;
	double phi_rot;
	part_log n;
	part_log n_rot;
	t_prop = brt.t;
	theta_int = brt.theta_int;
	phi_rot = brt.phi_rot;
	//printf("proptime %f", t_prop);
	if (t_prop < 0){
		return 0;
	}
	else{
		//if the time is valid we propagate the neutron to the surface
		propagate_neutron(neutron, t_prop);//propagate neutron
		n = return_normal_vec(logspir, theta_int);
		rotate_vector(&n_rot, n, -phi_rot);//
		reflect_neutron(n_rot, neutron, logspir.mValue);
		return 1;
	}
}



//double return_time_first_interaction(LogSpir logspir, double theta_int, part_log *n){
//	double z_int = cos(theta_int)*return_r(theta_int, logspir.k, logspir.zstart);
//	return z_int/n->vz;
//}


///////////////////////////////////////////////////////////////////////////
/////////////// End of functions
///////////////////////////////////////////////////////////////////////////
//part_log n;


%}


DECLARE
%{
	double dt;
	double theta_int;
	LogSpir logspir;
	LogSpir *logspirp;
	part_log normal;
%}

INITIALIZE
%{
	//printf("does this even fucking care\n");
	logspirp = &logspir;
    double psi_rad;//=psi*DEG2RAD;
    double k;//=arctan(psi_rad);
    double theta_end;
    double x_end;
	///////////////////////////////////////////////////////////////////////////
	/////////////// Initialize the logarithmic spiral
	///////////////////////////////////////////////////////////////////////////
	LogSpirinit(logspirp, zstart, zend, psi, phi_rot, mValue, precision, max_iterations, branches);

	printf("theta_end%f", logspir.theta_end);
%}

	// Test user input for illegal values

TRACE
%{
  part_log n;

  part_log *ptrn;
  ptrn = &n;
  //PROP_Z0;this not needed to allow neutrons from the other side to hit the logspiral
  //printf("\n z=%f y=%f x=%f vz=%f vy=%f vx=%f \n", z, y, x, vz, vy, vx);
  n = Neutron2Dinit(ptrn, z, y, x, vz, vy, vx);//puts all of the neutron info into the pointer ptrn pointing to n
  for (int ii = 0; ii < 100; ii++){
	  //propagate neutron to the next interaction
	  interaction = evaluate_first_interaction(logspir, ptrn);
	  //printf("ii %d , %d \n", ii, 0);
	  //printf("after interaction z = %f, x = %f, vz = %f, vx = %f\n", returnz(n), returnx(n), returnvz(n), returnvx(n));
	  if (interaction==0){
		  break;
	  }
  }
  z  = returnz(n);
  vz = returnvz(n);
  y  = returny(n);
  vy = returnvy(n);
  x  = returnx(n);
  vx = returnvx(n);
  //printf("\n z=%f y=%f x=%f vz=%f vy=%f vx=%f \n", z, y, x, vz, vy, vx);
   //


%}


FINALLY
%{
%}

MCDISPLAY
%{


%}

END
